{"meta":{"title":"Code Geek!","subtitle":"代码怪咖","description":"技术博客","author":"xxfeng","url":"http://codegeek.club","root":"/"},"pages":[{"title":"文章分类","date":"2022-01-16T17:15:10.000Z","updated":"2022-01-17T15:23:20.390Z","comments":true,"path":"categories/index.html","permalink":"http://codegeek.club/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenHarmony环境配置","slug":"OpenHarmony/OpenHarmony环境配置","date":"2022-01-16T16:29:35.000Z","updated":"2022-01-16T17:52:11.542Z","comments":true,"path":"2022/01/17/OpenHarmony/OpenHarmony环境配置/","link":"","permalink":"http://codegeek.club/2022/01/17/OpenHarmony/OpenHarmony%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"OpenHarmony环境配置","categories":[{"name":"OpenHarmony","slug":"OpenHarmony","permalink":"http://codegeek.club/categories/OpenHarmony/"}],"tags":[]},{"title":"Android中基于RefBase的强弱指针","slug":"Android/Android中基于RefBase的强弱指针","date":"2021-11-21T13:27:17.000Z","updated":"2022-01-17T15:20:46.069Z","comments":true,"path":"2021/11/21/Android/Android中基于RefBase的强弱指针/","link":"","permalink":"http://codegeek.club/2021/11/21/Android/Android%E4%B8%AD%E5%9F%BA%E4%BA%8ERefBase%E7%9A%84%E5%BC%BA%E5%BC%B1%E6%8C%87%E9%92%88/","excerpt":"&emsp;&emsp;观察AOSP的native代码，发现其中很多class都会继承RefBase，那么继承RefBase到底有哪些作用呢？观察声明RefBase的头文件[system/core/libutils/include/utils/RefBase.h]，里面有非常详细的注释，可以看到RefBase是为了智能指针wp和sp的使用而定义的。顾名思义，wp和sp指针为引用计数型指针，分为表示弱引用指针和强引用指针。但是众所周知，C++的标准库中也有引用计数型指针shared_ptr和weak_ptr，为什么Android不使用标准库中的引用计数型智能指针，而要自己造一套轮子呢？Android实现的wp和sp究竟相比于标准库的shared_ptr和unique_ptr有何优势？","text":"&emsp;&emsp;观察AOSP的native代码，发现其中很多class都会继承RefBase，那么继承RefBase到底有哪些作用呢？观察声明RefBase的头文件[system/core/libutils/include/utils/RefBase.h]，里面有非常详细的注释，可以看到RefBase是为了智能指针wp和sp的使用而定义的。顾名思义，wp和sp指针为引用计数型指针，分为表示弱引用指针和强引用指针。但是众所周知，C++的标准库中也有引用计数型指针shared_ptr和weak_ptr，为什么Android不使用标准库中的引用计数型智能指针，而要自己造一套轮子呢？Android实现的wp和sp究竟相比于标准库的shared_ptr和unique_ptr有何优势？ &emsp;&emsp;RefBase配合sp和wp实现了一套引用计数型指针，和std::shared_ptr不同的是，基于RefBase的sp是侵入式的引用计数指针，而标准库的shared_ptr是非侵入式的。侵入式的引用计数指针要求对象自身拥有引用计数节点，并且提供增减引用计数的接口（RefBase正是实现了这样的接口）；而非侵入式的引用计数指针对管理的对象本身没有要求，而是在对象外部维护独立的引用计数节点。 &emsp;&emsp;所以侵入式引用计数指针（如AOSP中基于RefBase的sp）的优点就是每一个智能指针都只需要管理对象的指针就行，因为对象自身中保存了一个引用计数节点；而不需要像shared_ptr这样的非侵入式智能指针一样，在每个shared_ptr中都得带上一个管理引用计数的节点。这样会节省一部分空间，而且也会因为程序局部性的关系，我猜测其比shared_ptr性能更好一点（当然这样的性能差异可能可以忽略不计，最终还得以实测为准）。而缺点呢，也十分明显，那就是想要使用sp指针管理对象指针时，该对象必须是继承了RefBase的，不然就没有办法进行引用计数的增减。 1. RefBase&emsp;&emsp;观察RefBase头文件中的class声明，可见其包含了一个成员mRefs，它的类型是weakref_impl，weakref_impl是一个前置声明，翻看RefBase.cpp可以看到class RefBase::weakref_impl : public RefBase::weakref_type的继承关系，而RefBase::weakref_type是一个纯接口类，其中提供了incWeak和decWeak等接口，顾名思义那就是增减弱引用计数的。那么增减强引用计数的接口在哪里呢？是直接声明在RefBase类中的。 123456789101112131415161718// RefBase的大致结构，为便于理解，有删减。class RefBase &#123;public: void incStrong(const void* id) const; void decStrong(const void* id) const; int32_t getStrongCount() const; class weakref_type &#123; public: void incWeak(const void* id); void decWeak(const void* id); int32_t getWeakCount() const; &#125;; weakref_type* createWeak(const void* id) const;private: friend class weakref_type; class weakref_impl; // class RefBase::weakref_impl : public RefBase::weakref_type weakref_impl* const mRefs;&#125;; &emsp;&emsp;现在我们对RefBase的结构有了大概的了解，它声明了incStrong和decStrong接口，用于增减强引用计数，类中又声明了weakref_type，它的incWeak和decWeak接口是用于增减弱引用计数的。继承自RefBase的每一个对象都会保存一个weakref_impl指针，指向该对象的引用节点，该引用节点继承自weakref_type类型。","categories":[{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]},{"title":"Android 12 源码漫游","slug":"Android/Android-12-源码漫游","date":"2021-11-19T15:31:29.000Z","updated":"2022-01-17T15:20:46.069Z","comments":true,"path":"2021/11/19/Android/Android-12-源码漫游/","link":"","permalink":"http://codegeek.club/2021/11/19/Android/Android-12-%E6%BA%90%E7%A0%81%E6%BC%AB%E6%B8%B8/","excerpt":"&emsp;&emsp;Android系统最新的版本已经是12.0，对于想要了解Android基础框架的人来说，查看其源码是一个不错的选择。Android源码由Google公司维护，全称为Android Open Source Project(AOSP)，那么接下来就是对AOSP的代码漫游之旅！","text":"&emsp;&emsp;Android系统最新的版本已经是12.0，对于想要了解Android基础框架的人来说，查看其源码是一个不错的选择。Android源码由Google公司维护，全称为Android Open Source Project(AOSP)，那么接下来就是对AOSP的代码漫游之旅！ &emsp;&emsp;工欲善其事，必先利其器。查看Android源码最好使用Linux系统，这里使用Ubuntu20.04 LTS。 1. 下载源码&emsp;&emsp;由于国内网络环境的问题，不能从Google的官方仓库下载AOSP代码。所以只能从国内的开源镜像站下载，著名的有清华的开源镜像站：https://mirrors.tuna.tsinghua.edu.cn/ 其网站上有完整的下载教程可供参考。 2. 源码编译&emsp;&emsp;下载AOSP代码完成之后，可以进行编译工作： 1234cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch 2 # 会弹出一个选择框，选择需要编译的系统类型，我们选择2(aosp_arm64-eng)make -j4 # 以4个线程并发进行编译构建，可根据配置自行调整 3. 准备源码阅读环境&emsp;&emsp;AOSP代码主要有两部分，一部分是Java语言编写的上层应用框架层，一部分是C++语言编写的native系统架构层，阅读这两部分的代码，都需要有一个合适的工具，推荐使用Jetbrains公司的IDE来阅读，分别是Android Studio（阅读Java框架代码）和Clion（阅读native系统框架的代码）。 3.1 首先是Java代码的准备，依次执行如下命令：1234567cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch # 会弹出一个选择框，选择需要编译的系统类型，如aosp_arm64-eng# 在源码根目录会生成android.iprmmm development/tools/idegen./development/tools/idegen/idegen.sh &emsp;&emsp;打开Android Studio，选择源码根目录中刚刚生成的android.ipr文件，静静等待代码索引的建立，之后就可以跳转代码啦。 3.2 接下来是native（C++）代码的准备：&emsp;&emsp;可以参考Google官方给出的文档https://android.googlesource.com/platform/build/soong/+/refs/heads/master/docs/clion.md 1234567cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch 2 # 会弹出一个选择框，选择需要编译的系统类型，我们选择2(aosp_arm64-eng)export SOONG_GEN_CMAKEFILES=1export SOONG_GEN_CMAKEFILES_DEBUG=1make -j4 &emsp;&emsp;等待编译完成，在源码根目录的out/development/ide/clion文件夹中就会生成系统所有C++模块的CMakeLists.txt文件，用Clion打开其中某个模块，比如out/development/ide/clion/frameworks/native/libs/gui/libgui-arm64-android，那么就可以查看native中gui库的代码，并支持跳转。&emsp;&emsp;当然也可以直接将out/development/ide/clion整个文件夹打开，然后自己添加CMakeLists.txt，利用add_subdirectory()将需要的模块目录添加进工程，这样就能按需查看native代码并且支持跳转啦！这时候会发现导入的源文件会以外部源文件的形式呈现在project中，原有的目录关系丢失了，这时候点击Tools–CMake–Change project root即可解决问题。&emsp;&emsp;如果没有Clion，也可以使用VSCode。&emsp;&emsp;1. 首先安装CMake-tools插件和clangd插件（clangd和c/c++插件是冲突的，可以卸载c/c++插件），注意修改一下VSCode的CMake-tools插件的Build Directory设置：&emsp;&emsp;2. 打开AOSP整个文件夹，在AOSP根目录添加一个CMakeLists.txt，利用add_subdirectory()将需要的模块目录添加进工程来。&emsp;&emsp;3.","categories":[{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]}],"categories":[{"name":"OpenHarmony","slug":"OpenHarmony","permalink":"http://codegeek.club/categories/OpenHarmony/"},{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]}