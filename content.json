{"meta":{"title":"Code Geek!","subtitle":"代码怪咖","description":"技术博客","author":"xxfeng","url":"http://codegeek.club","root":"/"},"pages":[{"title":"文章分类","date":"2022-01-16T17:15:10.000Z","updated":"2022-04-22T14:16:24.395Z","comments":true,"path":"categories/index.html","permalink":"http://codegeek.club/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"GDB图形化调试","slug":"Linux/GDB_With_UI","date":"2022-01-19T03:06:40.000Z","updated":"2022-04-24T07:28:51.095Z","comments":true,"path":"2022/01/19/Linux/GDB_With_UI/","link":"","permalink":"http://codegeek.club/2022/01/19/Linux/GDB_With_UI/","excerpt":"","text":"123456# 比如说要调试当前目录下的testgdb -tui ./test# 在gdb中运行set disassemble-next-line on，表示自动反汇编后面要执行的代码# 在gdb中运行layout regs, 就能实时监控寄存器的变化","categories":[{"name":"Linux","slug":"Linux","permalink":"http://codegeek.club/categories/Linux/"}],"tags":[]},{"title":"OpenHarmony环境配置","slug":"OpenHarmony/OpenHarmony环境配置","date":"2022-01-16T16:29:35.000Z","updated":"2022-04-24T07:28:51.095Z","comments":true,"path":"2022/01/17/OpenHarmony/OpenHarmony环境配置/","link":"","permalink":"http://codegeek.club/2022/01/17/OpenHarmony/OpenHarmony%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"","categories":[{"name":"OpenHarmony","slug":"OpenHarmony","permalink":"http://codegeek.club/categories/OpenHarmony/"}],"tags":[]},{"title":"Android中基于RefBase的强弱指针","slug":"Android/Android中基于RefBase的强弱指针","date":"2021-11-21T13:27:17.000Z","updated":"2022-04-24T09:27:42.767Z","comments":true,"path":"2021/11/21/Android/Android中基于RefBase的强弱指针/","link":"","permalink":"http://codegeek.club/2021/11/21/Android/Android%E4%B8%AD%E5%9F%BA%E4%BA%8ERefBase%E7%9A%84%E5%BC%BA%E5%BC%B1%E6%8C%87%E9%92%88/","excerpt":"观察AOSP的native代码，发现其中很多class都会继承RefBase，那么继承RefBase到底有哪些作用呢？观察声明RefBase的头文件[system/core/libutils/include/utils/RefBase.h]，里面有非常详细的注释，可以看到RefBase是为了智能指针wp和sp的使用而定义的。顾名思义，wp和sp指针为引用计数型指针，分为表示弱引用指针和强引用指针。但是众所周知，C++的标准库中也有引用计数型指针shared_ptr和weak_ptr，为什么Android不使用标准库中的引用计数型智能指针，而要自己造一套轮子呢？Android实现的wp和sp究竟相比于标准库的shared_ptr和unique_ptr有何区别？","text":"观察AOSP的native代码，发现其中很多class都会继承RefBase，那么继承RefBase到底有哪些作用呢？观察声明RefBase的头文件[system/core/libutils/include/utils/RefBase.h]，里面有非常详细的注释，可以看到RefBase是为了智能指针wp和sp的使用而定义的。顾名思义，wp和sp指针为引用计数型指针，分为表示弱引用指针和强引用指针。但是众所周知，C++的标准库中也有引用计数型指针shared_ptr和weak_ptr，为什么Android不使用标准库中的引用计数型智能指针，而要自己造一套轮子呢？Android实现的wp和sp究竟相比于标准库的shared_ptr和unique_ptr有何区别？ RefBase配合sp和wp实现了一套引用计数型指针，和std::shared_ptr不同的是，基于RefBase的sp是侵入式的引用计数指针，而标准库的shared_ptr是非侵入式的。侵入式的引用计数指针要求对象自身拥有引用计数节点，并且提供增减引用计数的接口（RefBase正是实现了这样的接口）；而非侵入式的引用计数指针对管理的对象本身没有要求，而是在对象外部维护独立的引用计数节点。 所以侵入式引用计数指针（如AOSP中基于RefBase的sp）的优点就是每一个智能指针都只需要管理对象的指针就行，因为对象自身中保存了一个引用计数节点；而不需要像shared_ptr这样的非侵入式智能指针一样，在每个shared_ptr中都得带上一个管理引用计数的节点。这样会节省一部分空间，而且也会因为程序局部性的关系，我猜测其比shared_ptr性能更好一点（当然这样的性能差异可能可以忽略不计，最终还得以实测为准）。而缺点呢，也十分明显，那就是想要使用sp指针管理对象指针时，该对象必须是继承了RefBase的，不然就没有办法进行引用计数的增减。 1. RefBase观察RefBase头文件中的class声明，可见其包含了一个成员mRefs，它的类型是weakref_impl，想必就是引用计数节点了。weakref_impl是一个前置声明，翻看RefBase.cpp可以看到class RefBase::weakref_impl : public RefBase::weakref_type的继承关系。RefBase::weakref_type是一个纯接口类，其中提供了incWeak和decWeak等接口，顾名思义那就是增减弱引用计数的。那么增减强引用计数的接口在哪里呢？是直接声明在RefBase类中的。 123456789101112131415161718// RefBase的大致结构，为便于理解，有删减。class RefBase &#123;public: void incStrong(const void* id) const; void decStrong(const void* id) const; int32_t getStrongCount() const; class weakref_type &#123; public: void incWeak(const void* id); void decWeak(const void* id); int32_t getWeakCount() const; &#125;; weakref_type* createWeak(const void* id) const;private: friend class weakref_type; class weakref_impl; // class RefBase::weakref_impl : public RefBase::weakref_type weakref_impl* const mRefs;&#125;; 现在我们对RefBase的结构有了大概的了解，它声明了incStrong和decStrong接口，用于增减强引用计数，类中又声明了weakref_type，它的incWeak和decWeak接口是用于增减弱引用计数的。继承自RefBase的每一个对象都会保存一个weakref_impl指针，指向该对象的引用节点，该引用节点继承自weakref_type类型。 1.1 weakref_impl简单观察一下weakref_impl的结构： 123456789101112131415161718192021222324252627282930class RefBase::weakref_impl : public RefBase::weakref_type&#123;public: std::atomic&lt;int32_t&gt; mStrong; std::atomic&lt;int32_t&gt; mWeak; RefBase* const mBase; std::atomic&lt;int32_t&gt; mFlags;#if !DEBUG_REFS // 非debug模式 explicit weakref_impl(RefBase* base) : mStrong(INITIAL_STRONG_VALUE) , mWeak(0) , mBase(base) , mFlags(OBJECT_LIFETIME_STRONG) &#123; &#125; void addStrongRef(const void* /*id*/) &#123; &#125; void removeStrongRef(const void* /*id*/) &#123; &#125; void renameStrongRefId(const void* /*old_id*/, const void* /*new_id*/) &#123; &#125; void addWeakRef(const void* /*id*/) &#123; &#125; void removeWeakRef(const void* /*id*/) &#123; &#125; void renameWeakRefId(const void* /*old_id*/, const void* /*new_id*/) &#123; &#125; void printRefs() const &#123; &#125; void trackMe(bool, bool) &#123; &#125;#else // 引用计数debug模式，有很多代码，我们暂时忽略它们#endif // DEBUG_REFS 我们看到weakref_impl有三个原子int32_t变量，它们分别是mStrong（强引用计数）、mWeak（弱引用计数）、mFlags（生命周期管理标志位）。mStrong和mWeak很好理解，这个mFlags的作用是什么呢？根据其默认初始化的值找到它们的枚举值定义的地方： 12345678910111213141516//! Flags for extendObjectLifetime()enum &#123; OBJECT_LIFETIME_STRONG = 0x0000, OBJECT_LIFETIME_WEAK = 0x0001, OBJECT_LIFETIME_MASK = 0x0001&#125;;// RefBase::extendObjectLifetime() can be used to prevent destruction of the// object while there are still weak references. This is really special purpose// functionality to support Binder.void RefBase::extendObjectLifetime(int32_t mode)&#123; // Must be happens-before ordered with respect to construction or any // operation that could destroy the object. mRefs-&gt;mFlags.fetch_or(mode, std::memory_order_relaxed);&#125; 配合RefBase::extendObjectLifetime()函数和其注释，我们可以知道，这个flag可以进行生命周期的管控策略调整。当flag为OBJECT_LIFETIME_STRONG时，是正常生命周期，对象会在强引用计数为0时便被析构（而不必关注弱引用计数的值是多少）。而当flag为OBJECT_LIFETIME_WEAK时，被称为是扩展的生命周期，即对象只有在强引用计数和弱引用计数都变为0时才真正析构。 在非debug模式下，我们可以看到weakref_impl的实现相当简单，仅仅是一个构造函数对三个变量的初始化，其他的所有函数都是空的（这些函数均是用于debug, 会在本章内容的最后探究如何提供debug信息时进行介绍）。这里有一点需要关注一下，就是mWeak是初始化为0，而mStrong则被初始化为 INITIAL_STRONG_VALUE，这是为什么呢？ 1#define INITIAL_STRONG_VALUE (1&lt;&lt;28) 这是因为，AOSP对所有基于Refase的对象提供了一个onFirstRef()，其作为一个回调函数，在对象首次构建并被sp指针引用时被调用。如果我们将mStrong简单地初始化为0，那么我们可能会分不清对象是初次构建还是最终需要销毁的状态。","categories":[{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]},{"title":"Android 12 源码漫游","slug":"Android/Android-12-源码漫游","date":"2021-11-19T15:31:29.000Z","updated":"2022-06-14T01:24:50.099Z","comments":true,"path":"2021/11/19/Android/Android-12-源码漫游/","link":"","permalink":"http://codegeek.club/2021/11/19/Android/Android-12-%E6%BA%90%E7%A0%81%E6%BC%AB%E6%B8%B8/","excerpt":"Android系统最新的版本已经是12.0，对于想要了解Android基础框架的人来说，查看其源码是一个不错的选择。Android源码由Google公司维护，全称为Android Open Source Project(AOSP)，那么接下来就是对AOSP的代码漫游之旅！","text":"Android系统最新的版本已经是12.0，对于想要了解Android基础框架的人来说，查看其源码是一个不错的选择。Android源码由Google公司维护，全称为Android Open Source Project(AOSP)，那么接下来就是对AOSP的代码漫游之旅！ 工欲善其事，必先利其器。查看Android源码最好使用Linux系统，这里使用Ubuntu 20.04 LTS。 1. 下载源码由于国内网络环境的问题，不能从Google的官方仓库下载AOSP代码。所以只能从国内的开源镜像站下载，著名的有清华的开源镜像站： https://mirrors.tuna.tsinghua.edu.cn/ 其网站上有完整的下载教程可供参考。 2. 源码编译下载AOSP代码完成之后，可以进行编译工作： 1234cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch 2 # 输入lunch会弹出一个选择框，选择需要编译的系统类型，我们默认选择2(aosp_arm64-eng)make -j4 # 开启四个并行任务进行编译构建，可根据配置自行调整 3. 准备源码阅读环境AOSP代码主要有两部分，一部分是Java语言编写的上层应用框架层，一部分是C++语言编写的native系统架构层，阅读这两部分的代码，都需要有一个合适的工具，推荐使用Jetbrains公司的IDE来阅读，分别是Android Studio（阅读Java框架代码）和Clion（阅读native系统框架的代码）。 3.1 首先是Java代码的准备，依次执行如下命令：1234567cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch 2 # 选择需要编译的系统类型，如2(aosp_arm64-eng)# 在源码根目录会生成android.iprmmm development/tools/idegen./development/tools/idegen/idegen.sh 打开Android Studio，选择源码根目录中刚刚生成的android.ipr文件，静静等待代码索引的建立，之后就可以跳转代码啦。 3.2 接下来是native（C++）代码的准备：3.2.1 使用CLion可以参考Google官方给出的文档: https://android.googlesource.com/platform/build/soong/+/refs/heads/master/docs/clion.md 1234567cd AOSP # cd进入下载好的AOSP代码目录source build/envsetup.sh # 初始化编译环境lunch 2 # 选择(aosp_arm64-eng)export SOONG_GEN_CMAKEFILES=1export SOONG_GEN_CMAKEFILES_DEBUG=1make -j4 等待编译完成，在源码根目录的out/development/ide/clion文件夹中就会生成系统所有C++模块的CMakeLists.txt文件，用Clion打开其中某个模块，比如 out/development/ide/clion/frameworks/native/libs/gui/libgui-arm64-android， 那么就可以查看native中gui库的代码，并支持跳转。 当然也可以直接将out/development/ide/clion整个文件夹打开，然后自己添加CMakeLists.txt，利用add_subdirectory()将需要的模块目录添加进工程，这样就能按需查看native代码并且支持跳转啦！这时候会发现导入的源文件会以外部源文件的形式呈现在project中，原有的目录关系丢失了，这时候点击Tools--CMake--Change project root即可解决问题。 3.2.2 使用VSCode如果没有Clion，也可以使用VSCode。 1. 首先安装CMake-tools插件和clangd插件（clangd和c/c++插件是冲突的，clangd对于c++代码的解析明显体验好于官方插件，可以考虑把官方c/c++插件卸载掉），注意修改一下VSCode的CMake-tools插件的Build Directory设置（防止VSCode自动生成的build目录和AOSP的build目录发生冲突）： 以及CMake Configure Args设置： 12# 增加如下configure arg-DCMAKE_EXPORT_COMPILE_COMMANDS=1 2. 打开AOSP整个文件夹，在AOSP根目录添加一个CMakeLists.txt，利用add_subdirectory()将需要的模块目录添加进工程来。这里提供一些供参考： 123456789101112131415161718192021222324cmake_minimum_required(VERSION 3.6)project(AOSP_Master)set(CMAKE_CXX_STANDARD 17)add_subdirectory(out/development/ide/clion/frameworks/native/libs/binder/libbinder-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/libs/dumputils/libdumputils-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/libs/gralloc/types/libgralloctypes-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/libs/input/libinput-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/libs/nativewindow/libnativewindow-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/libs/nativedisplay/libnativedisplay-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native)add_subdirectory(out/development/ide/clion/frameworks/native/cmds/atrace/atrace-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/cmds/dumpsys/libdumpsys-arm64-android)add_subdirectory(out/development/ide/clion/frameworks/native/cmds/dumpsys/dumpsys-arm64-android)add_subdirectory(out/development/ide/clion/system/libbase/libbase-arm64-android)add_subdirectory(out/development/ide/clion/system/core/libasyncio/libasyncio-arm64-android)add_subdirectory(out/development/ide/clion/system/core/libcutils/libcutils-arm64-android)add_subdirectory(out/development/ide/clion/system/core/libsync/libsync-arm64-android)add_subdirectory(out/development/ide/clion/system/core/libutils/libutils-arm64-android) 3. 由于AOSP使用自带的编译器，所以我们需要给VSCode手动增加一个CMakeTools kit。其中的编译器路径我们可以使用AOSP自动生成的CMakeLists.txt中指定的路径： 12345678910111213# 打开CMakeTools的kit配置文件vim ~/.local/share/CMakeTools/cmake-tools-kits.json# 增加如下kit, 保存并退出&#123; &quot;name&quot;: &quot;Clang AOSP master&quot;, &quot;compilers&quot;: &#123; # 这里的clang路径应该参考自动生成出来的的cmake文件中的编译器路径 # 具体路径根据自己代码位置决定，建议使用绝对路径 &quot;C&quot;: &quot;AOSP_ROOT/prebuilts/clang/host/linux-x86/clang-r437112b/bin/clang&quot;, &quot;CXX&quot;: &quot;AOSP_ROOT/prebuilts/clang/host/linux-x86/clang-r437112b/bin/clang++&quot; &#125;&#125; 4. 按F1，选择执行CMake Configuration操作(注意选择第三步添加的cmake toolkit进行configuration)。 5. CMake Configuration执行完毕后，可以看到在build-vscode文件夹下会生成一个compile_commands.json，把它软链接到AOSP根目录，就可以让clangd插件找到它并开始索引源码啦！初次建立索引的过程可能会有点慢，耐心等待一下即可。 123456# 在AOSP根目录执行，创建compile_commands.json的软链接ln -s build-vscode/compile_commands.json# VSCode的clangd插件需要依赖clangd服务# 可以选择apt安装，或者自行去clangd官网手动下载最新版sudo apt install clangd","categories":[{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://codegeek.club/categories/Linux/"},{"name":"OpenHarmony","slug":"OpenHarmony","permalink":"http://codegeek.club/categories/OpenHarmony/"},{"name":"Android","slug":"Android","permalink":"http://codegeek.club/categories/Android/"}],"tags":[]}